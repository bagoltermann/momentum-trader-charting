# Session Notes - 2026-01-19

## Status
Bug fix session - Exit button not working.

## Session Overview

1. User reported Exit button (upper right of dashboard) not working
2. Investigated Header.tsx handleExit function
3. Found root cause: missing async/await on IPC call
4. Fixed by making handleExit async and awaiting exitApp()
5. Verified Exit button now works correctly

---

## Bug: Exit Button Not Working

### Problem Reported
- Exit button in dashboard header (upper right) did not work when clicked
- File menu Exit option worked correctly
- Issue persisted across multiple attempts on Friday 01/16

### Investigation

Examined the following files:
- `src/renderer/components/layout/Header.tsx` - Exit button handler
- `src/main/preload.ts` - IPC bridge exposing exitApp
- `src/main/main.ts` - IPC handler for exit-app

### Root Cause Identified

The original `handleExit` function was **not awaiting** the async IPC call:

**Original Code (broken):**
```typescript
const handleExit = () => {
  if (window.electronAPI?.exitApp) {
    window.electronAPI.exitApp()
  }
}
```

**Issues:**
1. `exitApp()` returns a Promise (uses `ipcRenderer.invoke` which is async)
2. Without `await`, the function returns immediately before the IPC message is fully processed
3. The exit signal was being fired but not properly completing

### The Fix

**Fixed Code:**
```typescript
const handleExit = async () => {
  if (window.electronAPI?.exitApp) {
    try {
      await window.electronAPI.exitApp()
    } catch (err) {
      console.error('Exit failed:', err)
    }
  } else {
    console.error('electronAPI.exitApp not available')
    window.close()
  }
}
```

**Key Changes:**
1. Made function `async`
2. Added `await` before `window.electronAPI.exitApp()`
3. Added try/catch for error handling
4. Added fallback to `window.close()` if API unavailable
5. Added console.log statements for debugging (can be removed later)

---

## Files Modified

| File | Change |
|------|--------|
| `src/renderer/components/layout/Header.tsx` | Added async/await to handleExit |

---

## Key Takeaways

1. **Always await IPC calls** - `ipcRenderer.invoke()` returns a Promise; not awaiting it can cause the call to not complete properly
2. **File menu vs button** - The File menu Exit worked because Electron's menu system handles the action differently (synchronous menu callback)
3. **Debug logging helps** - Console.log statements helped confirm the issue was in the IPC call, not in the API availability

---

## Technical Details

### IPC Flow for Exit Button
```
Header.tsx (renderer)
  → handleExit() calls window.electronAPI.exitApp()
  → preload.ts bridges to ipcRenderer.invoke('exit-app')
  → main.ts handles 'exit-app' IPC
    → Sends POST to /api/shutdown (backend)
    → Calls app.quit()
```

### Why await Matters
Without `await`:
1. `exitApp()` starts the IPC call
2. Function returns immediately
3. React event handler completes
4. IPC may or may not finish depending on timing

With `await`:
1. `exitApp()` starts the IPC call
2. Function waits for Promise to resolve
3. IPC completes fully
4. Then function returns

---

## Testing Verification

- [x] Exit button now closes the app
- [x] App shuts down gracefully (backend stopped, Vite stopped)
- [x] Launcher.log shows clean shutdown sequence
- [x] App restarts successfully after exit

---

## Bug: Chart Switching Fails After 8-9 Selections

### Problem Reported
- First stock selection displays chart correctly
- Subsequent selections show same data OR blank charts
- After clicking through 8-9 stocks, all charts go blank
- Issue persisted even after selecting different stocks

### Investigation

**Initial findings:**
1. Console logs showed 4 duplicate API calls per symbol change
2. Components `MultiChartGrid`, `ExitSignalDashboard`, `SignalStrengthGauge`, `TimeframeAlignment` were each calling `useCandleData` hook independently
3. Backend was getting overwhelmed with requests

**Root cause:**
The Schwab client used **synchronous `httpx.Client`** inside **async FastAPI routes**. This blocked the event loop:
- First few requests worked fine
- As requests queued up, they blocked each other
- Eventually the event loop backed up and requests failed/timed out

### The Fix (Two Parts)

#### Part 1: Shared Candle Data Store

Created `candleDataStore.ts` (Zustand store) so only ONE component fetches candles:

```typescript
// candleDataStore.ts
export const useCandleDataStore = create<CandleDataState>((set, get) => ({
  primarySymbol: null,
  primaryCandles: [],
  primaryRaw: [],
  primaryLoading: false,
  primaryError: null,

  setPrimarySymbol: (symbol) => {
    // Cancel pending request
    if (pendingCancelToken) {
      pendingCancelToken.cancel('Symbol changed')
    }
    set({ primarySymbol: symbol, primaryCandles: [], primaryRaw: [] })
    if (symbol) get().fetchPrimaryCandles(symbol)
  },

  fetchPrimaryCandles: async (symbol) => {
    // Uses axios CancelToken to abort stale requests
    pendingCancelToken = axios.CancelToken.source()
    // ... fetch logic with cancellation support
  }
}))
```

**Components updated:**
- `MultiChartGrid.tsx` - Calls `setPrimarySymbol()`, reads from store
- `AnalysisPanels.tsx` - Reads `primaryCandles` from store, passes to children
- `SignalStrengthGauge.tsx` - Now receives `candles` as prop
- `ExitSignalDashboard.tsx` - Now receives `candles` as prop
- `TimeframeAlignment.tsx` - Now receives `candles` as prop

#### Part 2: Async Schwab Client (Critical Fix)

Converted backend from synchronous to async HTTP client:

**Before (blocking):**
```python
class ChartSchwabClient:
    def __init__(self):
        self._client = httpx.Client(...)  # Sync client

    def get_price_history(self, symbol, ...):  # Sync method
        response = self._client.get(...)  # Blocks event loop!
        return response.json()
```

**After (non-blocking):**
```python
class ChartSchwabClient:
    def __init__(self):
        self._client = httpx.AsyncClient(...)  # Async client

    async def get_price_history(self, symbol, ...):  # Async method
        response = await self._client.get(...)  # Non-blocking!
        return response.json()
```

**Routes updated:**
```python
@router.get("/candles/{symbol}")
async def get_candles(symbol: str, timeframe: str = "1m"):
    client = get_schwab_client()
    candles = await client.get_price_history(...)  # await added
    return candles
```

---

## Files Modified

| File | Change |
|------|--------|
| `src/renderer/store/candleDataStore.ts` | Created - Shared Zustand store for candle data |
| `src/renderer/components/charts/MultiChartGrid.tsx` | Uses store, added `key={primarySymbol}` |
| `src/renderer/components/panels/AnalysisPanels.tsx` | Reads from store, passes candles as props |
| `src/renderer/components/panels/SignalStrengthGauge.tsx` | Receives candles as prop |
| `src/renderer/components/panels/ExitSignalDashboard.tsx` | Receives candles as prop |
| `src/renderer/components/panels/TimeframeAlignment.tsx` | Receives candles as prop |
| `src/renderer/hooks/useCandleData.ts` | Added CancelToken support |
| `backend/services/schwab_client.py` | Changed to `httpx.AsyncClient` |
| `backend/api/routes.py` | Added `await` to client calls |
| `backend/main.py` | Added client cleanup on shutdown |

---

## Key Takeaways

1. **Never block async event loops** - Sync HTTP calls inside async FastAPI routes cause cascading failures under load
2. **Centralize data fetching** - Multiple components fetching same data = wasted requests and race conditions
3. **Cancel stale requests** - Use axios CancelToken or AbortController to prevent old responses updating state
4. **Use `key` prop for chart remount** - `key={symbol}` forces React to recreate the chart component on symbol change

---

## Technical Details

### Why Sync Calls Block FastAPI

FastAPI runs on uvicorn with asyncio. When you call a sync function from an async route:
1. The sync call blocks the current thread
2. Other async tasks can't run until it completes
3. With multiple rapid requests, they queue up
4. Eventually timeouts and failures occur

### Request Flow After Fix

```
User clicks stock in watchlist
  → App.tsx sets selectedSymbol
  → MultiChartGrid calls setPrimarySymbol(symbol)
  → Store cancels any pending request
  → Store clears old candles, sets new symbol
  → Store calls fetchPrimaryCandles(symbol)
  → Axios GET /api/candles/{symbol} (with CancelToken)
  → FastAPI route awaits async client.get_price_history()
  → httpx.AsyncClient makes non-blocking HTTP call
  → Response returns, store updates
  → All components reading from store re-render with new data
```

---

## Testing Verification

- [x] Can click through all 11+ watchlist stocks without blank charts
- [x] Charts display correct data for each symbol
- [x] Rapid clicking doesn't cause race conditions
- [x] Backend doesn't get overwhelmed
- [x] Request cancellation works (no stale data displayed)

---

**Last Updated**: 2026-01-20
