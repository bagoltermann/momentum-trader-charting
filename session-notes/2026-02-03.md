# Session Notes - 2026-02-03

## Status
Fixed event loop deadlock caused by httpx.Response objects crossing thread boundaries (Fix #22). Added watchdog thread for freeze detection.

## Session Overview
1. **Morning**: Diagnose backend hang after 1+ hour of stable operation
2. **Morning**: Fix #22 - Prevent event loop deadlock from thread pool response objects
3. **Morning**: Add independent watchdog thread for event loop freeze detection
4. **Morning**: Confirm duplicate HistoricalPatternMatch logs are React StrictMode (harmless)

---

## Work Completed

### 1. Fix #22: Thread Pool Response Object Deadlock

**Commit**: `be7b01f`

**Problem**: Backend froze at 09:43:33 after running stably for 1+ hour (~540 successful requests). Console showed timeouts for all candle fetches, watchlist, and WebSocket.

**Evidence from `logs/backend.log`**:
```
09:43:33 [INFO] make_api_request: Starting request to .../pricehistory  (x3)
09:43:33 [INFO] HTTP Request: GET .../pricehistory?symbol=TOYO... "HTTP/1.1 200 OK"
09:43:33 [INFO] HTTP Request: GET .../pricehistory?symbol=JLHL... "HTTP/1.1 200 OK"
09:43:33 [INFO] HTTP Request: GET .../pricehistory?symbol=JLHL... "HTTP/1.1 200 OK"
-- 5 MINUTES OF SILENCE -- (no heartbeat, no "Got response status", nothing)
09:48:23 [INFO] Runners reloaded  (from independent file watcher thread)
```

Key observations:
- httpx logged "200 OK" from **inside** the thread pool workers (those log lines come from within `_sync_request`)
- But `make_api_request: Got response status` **never appeared** - meaning `await asyncio.to_thread()` never returned
- Heartbeat #316 was the last (09:43:27), then silence
- Only the file watcher thread (independent of event loop) kept running

**Root Cause**: `_sync_request()` returned `httpx.Response` objects containing live socket/connection references across the thread boundary. When 3 threads completed simultaneously at 09:43:33, the `WindowsSelectorEventLoop` deadlocked trying to process multiple cross-thread results with socket objects.

**Solution**: Parse all response data inside the thread pool worker and return a plain `dict`:

```python
def _sync_request(url: str, params: Dict, headers: Dict) -> Dict:
    with httpx.Client(
        timeout=httpx.Timeout(10.0, connect=5.0),
        http2=False
    ) as client:
        response = client.get(url, params=params, headers=headers)
        # Extract everything inside the thread - no socket objects cross back
        return {
            'status_code': response.status_code,
            'json': response.json() if response.status_code == 200 else None,
            'text': response.text if response.status_code != 200 else None,
        }
```

All callers updated to use dict access (`response['status_code']`, `response['json']`) instead of attribute access.

**Files Modified**:
- `backend/services/schwab_client.py` - `_sync_request()`, `make_api_request()`, `get_price_history()`, `get_quote()`
- `backend/main.py` - Added watchdog thread

---

### 2. Watchdog Thread for Freeze Detection

**Commit**: `be7b01f` (same commit)

**Problem**: The existing heartbeat runs ON the event loop, so when the loop freezes, the heartbeat stops too. There's no way to know the loop is frozen until you check the log and notice the gap.

**Solution**: Added an independent watchdog thread that checks the heartbeat timestamp:

```python
def _watchdog_thread():
    while True:
        time.sleep(45)  # Check every 45s (heartbeat is 30s)
        elapsed = time.time() - _last_heartbeat_time
        if elapsed > 90:   # 3 missed heartbeats
            _wd_logger.error("[WATCHDOG] Event loop appears FROZEN...")
        elif elapsed > 60:  # 2 missed heartbeats
            _wd_logger.warning("[WATCHDOG] Event loop may be stalled...")
```

The watchdog logs to `logs/backend.log` even when the event loop is dead, providing immediate visibility into freezes.

---

### 3. Duplicate HistoricalPatternMatch Analysis - React StrictMode

**Finding**: The duplicate analysis logs that persist after the useMemo fix are caused by **React StrictMode** (`src/renderer/index.tsx:7`), which intentionally double-renders components in development mode.

This is by design and harmless:
- The computation is cheap (comparing against ~28 trades)
- Does not occur in production builds
- Not a bug in our code

---

## Testing Checklist

- [ ] Restart charting app and verify backend starts with watchdog
- [ ] Monitor `logs/backend.log` for `[WATCHDOG]` entries (should see none if healthy)
- [ ] Verify backend survives 1+ hour of operation without freezing
- [ ] Verify pre-market candles display (needExtendedHoursData fix from yesterday)

## Files Modified

| File | Changes | Commit |
|------|---------|--------|
| `backend/services/schwab_client.py` | Return dict instead of httpx.Response from thread pool, update all callers | be7b01f |
| `backend/main.py` | Add watchdog thread for freeze detection | be7b01f |
| `docs/session-notes/2026-01-27-chart-not-displaying-troubleshooting.md` | Added failure mode #22 | (this commit) |

## Key Takeaways

1. **Never pass socket objects across thread boundaries on Windows**: `httpx.Response` objects hold socket references. When multiple threads return them simultaneously to `WindowsSelectorEventLoop`, it can deadlock. Always extract plain data inside the thread.
2. **Intermittent bugs need specific conditions**: This bug required 3+ threads to complete at the exact same moment. Worked fine for 540+ requests before triggering.
3. **Independent monitoring**: An async heartbeat can't detect event loop freezes because it runs on the event loop. Use a separate thread for watchdog monitoring.
4. **React StrictMode double-renders**: In development, useMemo and effects run twice. This is by design and not a bug.

## Next Steps

1. Restart charting app and verify fix under load
2. Monitor watchdog thread output in logs
3. If freeze recurs, watchdog will provide timing info for further diagnosis

---

**Session Duration**: ~45 minutes
