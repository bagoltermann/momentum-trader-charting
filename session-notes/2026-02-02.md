# Session Notes - 2026-02-02

## Status
Fixed SSL event loop blocking in Schwab client (morning session), then fixed duplicate HistoricalPatternMatch analysis calls and watchlist request pileup (afternoon session).

## Session Overview
1. **Morning**: Fix #16 - Run httpx in thread pool to prevent SSL blocking event loop
2. **Afternoon**: Fix duplicate analysis calls in HistoricalPatternMatch component
3. **Afternoon**: Add request deduplication to watchlist polling

---

## Work Completed

### 1. Fix #16: Run httpx in Thread Pool (Morning Session)

**Commit**: `c1c7230`

**Problem**: On Windows, httpx.AsyncClient was blocking the asyncio event loop during SSL/TLS handshake operations. This caused the backend to hang despite the `asyncio.wait_for()` timeout wrappers - the timeout can't fire if the event loop itself is blocked.

**Root Cause**: SSL/TLS operations in httpx.AsyncClient on Windows can perform blocking I/O that freezes the entire event loop. This is a known issue with Windows + asyncio + SSL.

**Solution**: Use synchronous `httpx.Client` inside `asyncio.to_thread()` so the SSL operations run in a thread pool worker and can't block the event loop:

```python
def _sync_request(url: str, params: Dict, headers: Dict) -> httpx.Response:
    """Synchronous request - run in thread pool to prevent blocking event loop."""
    with httpx.Client(
        timeout=httpx.Timeout(10.0, connect=5.0),
        http2=False
    ) as client:
        response = client.get(url, params=params, headers=headers)
        return response

async def make_api_request(url: str, params: Dict, headers: Dict) -> Optional[httpx.Response]:
    """Make API request using httpx in a thread pool."""
    try:
        # Run sync httpx in thread pool - prevents SSL/TLS from blocking event loop
        response = await asyncio.wait_for(
            asyncio.to_thread(_sync_request, url, params, headers),
            timeout=15.0  # Hard timeout on the thread
        )
        return response
    except asyncio.TimeoutError:
        _logger.warning(f"make_api_request: Hard timeout after 15s")
        raise
```

**Key Points**:
- This is the "nuclear option" but proven reliable on Windows
- Thread pool has 50 workers (configured in main.py startup)
- More than enough for max 5 concurrent Schwab API requests

**File Modified**: `backend/services/schwab_client.py`

---

### 2. Fix Duplicate HistoricalPatternMatch Analysis Calls (Afternoon Session)

**Problem**: Every symbol analysis was running twice, as seen in console logs:
```
[HistoricalPatternMatch] Analyzing setup: PSIG against 28 trades
[HistoricalPatternMatch] Analysis result: 3 similar trades found
[HistoricalPatternMatch] Analyzing setup: PSIG against 28 trades  <-- duplicate
[HistoricalPatternMatch] Analysis result: 3 similar trades found  <-- duplicate
```

**Root Cause**: The `useMemo` for `setupData` was depending on entire `runners` and `watchlist` arrays:
```typescript
// OLD - triggers on any array change
const setupData = useMemo(() => {
  // ...
}, [selectedSymbol, runners, watchlist])
```

When the arrays update (even if the selected symbol's data is unchanged), React creates new object references, triggering the downstream `analysis` useMemo.

**Solution**: Extract the specific item first, then only depend on its individual field values:
```typescript
// NEW - only triggers when selected item's fields change
const runner = runners.find(r => r.symbol === selectedSymbol)
const watchItem = watchlist.find(w => w.symbol === selectedSymbol)

const setupData = useMemo(() => {
  // ...
}, [
  selectedSymbol,
  runner?.symbol,
  runner?.current_price,
  runner?.original_gap_percent,
  runner?.original_catalyst,
  watchItem?.symbol,
  watchItem?.price,
  watchItem?.gap_percent,
  watchItem?.llm_analysis?.catalyst_type,
  watchItem?.float,
  watchItem?.volume_ratio
])
```

**File Modified**: `src/renderer/components/panels/HistoricalPatternMatch.tsx:309-355`

---

### 3. Fix Watchlist Request Pileup (Afternoon Session)

**Problem**: Console showed 251+ failed watchlist requests:
```
watchlistStore.ts:62 [Watchlist] Primary fetch failed: timeout of 10000ms exceeded
251watchlistStore.ts:62 [Watchlist] Primary fetch failed: timeout of 10000ms exceeded
```

**Root Cause**: The watchlist polls every 5 seconds with a 10 second timeout. When the backend is slow:
1. Request 1 starts at t=0
2. Request 2 starts at t=5s (while Request 1 still pending)
3. Request 3 starts at t=10s (while 1 and 2 pending)
4. Requests pile up exponentially

Each timed-out request also triggers a fallback request to port 8080, doubling the load.

**Solution**: Added request deduplication using Axios CancelToken:
```typescript
// Track in-flight request to prevent pileup
let pendingRequest: CancelTokenSource | null = null

fetchWatchlist: async () => {
  // Cancel any pending request to prevent pileup
  if (pendingRequest) {
    pendingRequest.cancel('New request supersedes')
    pendingRequest = null
  }

  const cancelSource = axios.CancelToken.source()
  pendingRequest = cancelSource

  try {
    const response = await apiClient.get('http://localhost:8081/api/watchlist', {
      cancelToken: cancelSource.token
    })
    pendingRequest = null
    // ... handle response
  } catch (err) {
    pendingRequest = null
    if (axios.isCancel(err)) {
      return  // Ignore cancelled requests
    }
    // ... error handling
  }
}
```

**File Modified**: `src/renderer/store/watchlistStore.ts:1-99`

---

### 4. Backend Timeout Root Cause Analysis

**Finding**: The afternoon timeouts were caused by the **trader app (port 8080) being unresponsive**. The cascade:

1. Charting backend (8081) fetches watchlist from trader app (8080) -> times out
2. Quote relay can't connect to trader app's SocketIO -> WebSocket fails
3. Frontend falls back to REST polling -> also times out

The charting app depends on the trader app for:
- Watchlist data (`GET http://localhost:8080/api/watchlist`)
- Real-time quote streaming (SocketIO on port 8080)

---

## Testing Checklist

- [ ] Start charting app with trader app running
- [ ] Verify HistoricalPatternMatch analysis logs appear only ONCE per symbol
- [ ] Verify watchlist fetch errors don't pile up (should see at most 1 in-flight at a time)
- [ ] Verify Schwab API calls complete without blocking (httpx thread pool fix)

## Files Modified

| File | Changes | Commit |
|------|---------|--------|
| `backend/services/schwab_client.py` | Run httpx in thread pool to prevent SSL blocking | c1c7230 |
| `src/renderer/components/panels/HistoricalPatternMatch.tsx` | Fixed useMemo dependencies to prevent duplicate analysis calls | (pending) |
| `src/renderer/store/watchlistStore.ts` | Added CancelToken for request deduplication | (pending) |
| `docs/session-notes/2026-01-27-chart-not-displaying-troubleshooting.md` | Added failure modes #19, #20, #21 | (pending) |

## Key Takeaways

1. **Windows + asyncio + SSL**: httpx.AsyncClient can block the event loop on Windows during SSL handshakes. Use `asyncio.to_thread()` with sync client as workaround.
2. **useMemo with arrays**: When a useMemo depends on array props, extract the specific item first and depend on its scalar values - not the array reference.
3. **Request pileup**: Always deduplicate polling requests when timeout > interval (or when backend can be slow).
4. **Cascading failures**: Backend service dependencies should be clearly documented - the charting app's stability depends on the trader app.

## Next Steps

1. Monitor for any remaining duplicate analysis calls
2. Consider adding circuit breaker pattern to watchlist fetching (stop polling after N consecutive failures)
3. Verify trader app (port 8080) is running properly when testing

---

**Session Duration**: Morning (~1 hour) + Afternoon (~30 minutes)
