# Session Notes - 2026-02-05

## Status
Fix #24: Identified and fixed websockets library logging to stdout blocking the event loop. Stack dump from watchdog thread showed MainThread stuck in `stream.write()` when websockets logged "connection closed".

## Session Overview
1. **Morning**: Backend froze at 08:30:39 during pre-market trading
2. **Morning**: Watchdog captured first successful stack dump showing exact blocking location
3. **Morning**: Identified websockets library logging to stdout as root cause
4. **Morning**: Implemented Fix #24 - redirect all third-party loggers to file only

---

## Work Completed

### 1. Fix #24: websockets Library Logging to stdout Blocks Event Loop

**Problem**: Backend froze at 08:30:39. Watchdog detected freeze at 08:31:32 and captured stack dump.

**Key Evidence from `logs/watchdog.log`**:
```
2026-02-05 08:31:47 [ERROR] [WATCHDOG] Event loop FROZEN - no heartbeat for 74s
2026-02-05 08:31:47 [ERROR] [WATCHDOG] === THREAD STACK DUMP ===

--- Thread 83576 (MainThread) ---
  File "...\websockets\legacy\server.py", line 263, in handler
      self.logger.info("connection closed")
  File "...\logging\__init__.py", line 1163, in emit
      stream.write(msg + self.terminator)
```

**Root Cause**: The `websockets` library (used by FastAPI/Starlette for WebSocket support) has its own logger that writes to stdout by default. When a WebSocket connection closes, it logs "connection closed" via `stream.write()` to stdout. On Windows, stdout writes can block indefinitely if the console buffer is full or in certain states.

**Why Previous Fixes Didn't Catch This**:
- Fix #18 (print blocking) - We replaced all OUR `print()` calls with logging
- Fix #23 (asyncio.Queue) - Fixed cross-thread queue access
- But third-party libraries (websockets, uvicorn, socketio) still had their default StreamHandlers pointing to stdout

**Fix**: Redirect ALL third-party loggers to file only:

```python
def _configure_third_party_logging():
    """Configure third-party loggers to use file only, no stdout."""
    root_handlers = logging.getLogger().handlers
    file_handler = None
    for h in root_handlers:
        if isinstance(h, logging.FileHandler):
            file_handler = h
            break

    third_party_loggers = [
        'websockets', 'websockets.client', 'websockets.server', 'websockets.protocol',
        'uvicorn', 'uvicorn.error', 'uvicorn.access',
        'httpx', 'httpcore', 'socketio', 'engineio',
    ]

    for logger_name in third_party_loggers:
        logger = logging.getLogger(logger_name)
        logger.handlers = []  # Remove default StreamHandler
        logger.propagate = False  # Don't propagate to root
        if file_handler:
            logger.addHandler(file_handler)  # Use our file handler
        if logger_name.startswith('websockets') or logger_name.startswith('http'):
            logger.setLevel(logging.WARNING)
        else:
            logger.setLevel(logging.INFO)

_configure_third_party_logging()
```

**File Modified**: `backend/services/schwab_client.py:37-79`

---

### 2. Watchdog Stack Dump Worked!

The diagnostic instrumentation added yesterday (Fix #23 afternoon session) successfully captured the exact blocking location. This was the first successful stack dump during a freeze.

Key insight: The MainThread was NOT stuck on:
- asyncio.Queue (Fix #23)
- File I/O logging lock (suspected)
- httpx SSL operations (Fix #19)

It was stuck on **websockets library logging to stdout** - a third-party library we hadn't considered.

---

## Investigation: "No trades yet" Pre-Market Behavior

User asked about inconsistency where some stocks show "No trades yet" while others show data during pre-market.

**Finding**: This is expected behavior due to how Schwab API returns data:
- Backend requests pre-market candles starting at 4 AM ET with `needExtendedHoursData=true`
- Schwab returns different data quality per stock:
  - Stocks with actual pre-market trades → real OHLC candles
  - Stocks with no trades yet → placeholder candles with all zeros
- Frontend filters zero-value candles (OHLC all = 0) as invalid
- Result: "No trades yet" when ALL returned candles are zeros

The trader app may find stocks via news/catalyst scanning, but Schwab's pricehistory API requires actual executed trades to form candles. Bid/ask movement alone doesn't create candle data.

---

## Testing Checklist

- [ ] Restart charting app with Fix #24
- [ ] Monitor for backend stability during trading session
- [ ] Verify no freezes occur during WebSocket reconnections
- [ ] Check `logs/watchdog.log` - should have no new freeze entries
- [ ] If freeze occurs, check stack dump to verify it's NOT in `stream.write()`

## Files Modified

| File | Changes |
|------|---------|
| `backend/services/schwab_client.py` | Fix #24: Added `_configure_third_party_logging()` to redirect websockets/uvicorn/socketio loggers to file only |
| `docs/session-notes/2026-01-27-chart-not-displaying-troubleshooting.md` | Added failure mode #24 |

## Key Takeaways

1. **Stack dumps are essential**: The watchdog's stack dump immediately pinpointed the exact blocking call - no guessing needed.
2. **Third-party libraries have their own loggers**: Even with file-based logging for our code, third-party libraries (websockets, uvicorn) still use their default StreamHandlers to stdout.
3. **Windows stdout is treacherous**: Console output on Windows can block in ways that don't happen on Linux. Never write to stdout from async code.
4. **Defense in depth**: After Fix #24, ALL logging (ours + third-party) goes to file only. No more stdout writes from the backend process.

## Next Steps

1. **Monitor** - Run charting app during trading session to verify stability
2. **If freeze occurs** - Check `logs/watchdog.log` stack dump for new blocking locations
3. **Consider async logging** - If file I/O becomes an issue, implement QueueHandler for truly non-blocking logging

---

**Session Duration**: ~30 minutes
