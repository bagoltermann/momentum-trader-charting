# Session Notes - 2026-02-21

## Status
Implemented Volume Spike Alert Overlay (Idea #7) with stability-first REST polling architecture. Zero WebSocket changes.

## Session Overview
1. **Volume Spike Alert Overlay (Idea #7)** - Full implementation from plan to build
2. **Stability-first architecture** - REST polling chosen over WebSocket push after identifying 3 risks
3. **Professional trading strategy review** - Plan reviewed from Warrior Trading perspective
4. **All-watchlist scope** - Changed from active-symbol-only to all-watchlist alerts after strategy review

## Work Completed

### Volume Spike Alert Overlay (Idea #7) - Full Implementation

**Context**: The trader app (v2.7.0) has a `VolumeSpikeCache` that emits `volume_spike` SocketIO events when volume acceleration is detected (3x normal threshold, first-hour 0.8x sensitivity). The charting app's `QuoteRelay` was already connected to the trader app via SocketIO but wasn't listening for this event.

**Architecture Decision**: After identifying 3 stability risks with WebSocket push approach (duplicate WebSocket connections, shared data dict mutation, modifying stability-critical WebSocket handler), switched to REST polling — same proven pattern as VWAP (2s) and Rotation (10s).

#### Step 1: QuoteRelay — Volume Spike Listener + Storage

**File**: `backend/services/quote_relay.py`

Added `volume_spike` SocketIO listener that stores spikes in a dict with auto-expiry:
- `_active_spikes` dict with 30s TTL
- `copy.copy(data)` to never mutate shared SocketIO event dicts
- `get_active_spikes()` with lazy expiry pruning (no background timer)
- `_on_volume_spike()` logs spike symbol and ratio

```python
def _on_volume_spike(self, data):
    symbol = data.get('symbol')
    if symbol:
        spike = copy.copy(data)
        spike['received_at'] = time.time()
        self._active_spikes[symbol] = spike
```

#### Step 2: REST Endpoint

**File**: `backend/api/routes.py`

Added `GET /api/volume-spikes/active` — pure dict read from QuoteRelay, no httpx proxy needed since data is already captured locally:

```python
@router.get("/volume-spikes/active")
async def get_active_volume_spikes():
    if not _quote_relay:
        return {"spikes": {}}
    return {"spikes": _quote_relay.get_active_spikes()}
```

#### Step 3: Frontend Hook — useVolumeSpikeAlerts

**New file**: `src/renderer/hooks/useVolumeSpikeAlerts.ts`

- Feature flag: `VOLUME_SPIKE_ALERTS_ENABLED = true`
- 5s polling to `/api/volume-spikes/active`
- AbortController cleanup, mountedRef guard
- Smart re-render avoidance: only updates state when spike count changes
- Returns `{ activeSpikes: Map<string, VolumeSpikeEvent>, spikingSymbols: Set<string> }`

#### Step 4: Sidebar Flash

**File**: `src/renderer/components/layout/Sidebar.tsx`

- Added optional `spikingSymbols?: Set<string>` prop
- Conditional `spiking` CSS class triggers orange flash animation (3 pulses)
- All watchlist symbols flash when spiking, not just the active chart

#### Step 5: Chart Badge

**File**: `src/renderer/components/charts/EnhancedChart.tsx`

- Added optional `volumeSpike?: { spike_ratio: number } | null` prop
- "VOL SPIKE Nx" badge appears as first item in chart-header-right (before SETUP, BULL FLAG)
- Hot orange styling (#FF5722) matches sidebar flash

#### Step 6: App.tsx Wiring

**File**: `src/renderer/App.tsx`

- Imported `useVolumeSpikeAlerts` hook
- Computed `volumeSpike` for active symbol from `activeSpikes` map
- Passed `spikingSymbols` to Sidebar, `volumeSpike` through MultiChartGrid to EnhancedChart

#### Step 7: CSS Styling

**File**: `src/renderer/styles/global.css`

- `.pattern-badge.volume-spike-badge` — hot orange with matching border
- `.symbol-item.spiking` — `spike-flash` animation (3 orange pulses)

### Key Architectural Decisions

1. **REST polling over WebSocket push**: Avoids modifying stability-critical WebSocket handler. Same pattern as VWAP and Rotation — proven stable.
2. **All-watchlist alerts**: Professional trading strategy review identified that showing spikes only for the active chart symbol was insufficient for multi-stock day trading. Sidebar flash covers all symbols.
3. **Feature flag**: `VOLUME_SPIKE_ALERTS_ENABLED` constant allows instant disable without code revert.
4. **copy.copy() for SocketIO data**: Never mutate shared event dicts — critical safety pattern identified during stability review.
5. **Lazy expiry**: Backend prunes expired spikes on read (no background timer) — simpler and safer.

### Stability Safeguards

- **Zero WebSocket changes**: `useStreamingQuotes.ts`, `ws_quotes`, `_ws_send_loop`, `candleDataStore.ts` all untouched
- **Additive only**: QuoteRelay gets a new listener + dict — existing callbacks untouched
- **Isolated state**: Spike dict lives in QuoteRelay, not in candle store or quote processing
- **Feature flag**: `VOLUME_SPIKE_ALERTS_ENABLED = false` disables all polling and UI
- **Graceful fallback**: Backend not running = endpoint returns `{"spikes": {}}` = no UI changes

## Testing Checklist

- [x] Build succeeds with zero TypeScript errors
- [x] `GET /api/volume-spikes/active` returns `{"spikes": {}}` when no spikes active
- [ ] Sidebar flash: When any watchlist symbol spikes, its row flashes orange 3 times (market hours)
- [ ] Chart badge: When active chart's symbol spikes, "VOL SPIKE Nx" badge appears with orange pulse (market hours)
- [ ] Auto-expire: Badge and flash clear after 30 seconds (backend expiry)
- [ ] Cross-symbol: Spike on symbol B while viewing symbol A flashes Sidebar only
- [ ] Feature flag: Setting `VOLUME_SPIKE_ALERTS_ENABLED = false` stops polling, no UI changes
- [ ] Trader app down: QuoteRelay not connected, endpoint returns empty — no errors

## Files Modified

| File | Change | Commit |
|------|--------|--------|
| `backend/services/quote_relay.py` | Added `volume_spike` listener + `_active_spikes` dict | pending |
| `backend/api/routes.py` | Added `GET /volume-spikes/active` endpoint | pending |
| `src/renderer/hooks/useVolumeSpikeAlerts.ts` | **NEW** — 5s polling hook with feature flag | pending |
| `src/renderer/components/layout/Sidebar.tsx` | Optional `spikingSymbols` prop, `spiking` CSS class | pending |
| `src/renderer/components/charts/EnhancedChart.tsx` | Optional `volumeSpike` prop, VOL SPIKE badge | pending |
| `src/renderer/components/charts/MultiChartGrid.tsx` | Pass-through `volumeSpike` prop | pending |
| `src/renderer/App.tsx` | Hook integration, prop wiring | pending |
| `src/renderer/styles/global.css` | Spike badge + sidebar flash styles | pending |
| `FEATURE_SUGGESTIONS.md` | Idea #7 marked IMPLEMENTED | pending |

## Data Flow

```
Trader App VolumeSpikeCache detects spike
  -> main.py._on_volume_spike()
    -> socketio.emit('volume_spike', spike_data)
      -> QuoteRelay._on_volume_spike()           [NEW listener]
        -> _active_spikes[symbol] = copy(data)    [NEW dict storage]

Frontend polls every 5s:
  useVolumeSpikeAlerts -> GET /api/volume-spikes/active  [NEW endpoint]
    -> _quote_relay.get_active_spikes()                  [NEW method]
      -> Returns non-expired spikes
        -> Sidebar: orange flash on spiking row (ALL symbols)
        -> EnhancedChart: pulsing "VOL SPIKE 3.5x" badge (active symbol)
```

## Key Takeaways

1. **REST polling is the stability-safe pattern** for consuming trader app data. WebSocket push requires modifying stability-critical code paths.
2. **copy.copy() on SocketIO data** is essential — mutating shared event dicts can cause subtle bugs across all consumers.
3. **All-watchlist scope** is critical for day trading — can't afford to miss a spike because you're looking at a different chart.
4. **Feature flags** give confidence to ship new features — instant rollback without code changes.
5. **The 404 errors** for candles (GP, VGAS, MNDR, CNVS) are pre-existing — Schwab doesn't have intraday data for these symbols. Not related to Volume Spike changes.

## Next Steps

- [ ] Verify Volume Spike alerts during market hours (need actual volume spikes)
- [ ] Consider adding audio cue for volume spikes (future enhancement)
- [ ] Consider spike history panel (future enhancement)
- [ ] Investigate 404 candle errors for secondary runner charts (pre-existing, low priority)
