# Session Notes - 2026-01-27

## Status
Backend freeze fix (4 fixes) + zombie process cleanup + troubleshooting documentation. All changes implemented and verified, not yet committed.

## Session Overview
1. Charts not displaying - continued from prior session (semaphore starvation root cause)
2. Zombie process cleanup - processes lingering after app exit, blocking restart
3. Troubleshooting documentation - created diagnosis flowcharts for known failure modes
4. XHLD Five Pillars analysis - charting app vs trading app discrepancy review
5. Backend freeze root cause analysis - synchronous LLM calls blocking async event loop
6. Plan mode: 4-commit fix strategy for backend freeze
7. Implementation of all 4 fixes with performance verification

## Problem Analysis

### Backend Freeze - Root Cause
The charting app backend would freeze over time (zero log entries, all requests hung). Two interconnected issues:

1. **Synchronous LLM calls block the async event loop** - `_call_llm_with_json_extraction()` calls `requests.post()` (60s timeout) inside an async FastAPI handler, freezing the single-threaded uvicorn event loop for up to 60s per validation
2. **React dependency cascade fires validation every 5s instead of 60s** - watchlist poll (5s) creates new array reference -> recreates useCallback -> re-triggers useEffect -> calls validateTop3() immediately + resets 60s timer

Combined effect: the backend gets hit with synchronous blocking LLM calls every 5 seconds. Each one freezes the event loop, preventing candle fetches, health checks, and all other requests.

### Zombie Processes - Root Cause
- `launcher.py` cleanup used `taskkill /F /T /PID` (tree kill) which walked the process tree and killed unrelated trader app processes
- No cleanup on abnormal exit (crash, Task Manager kill)
- No startup check for stale processes from previous runs

### Five Pillars Discrepancy (XHLD)
Charting app showed 5/5 green, trading app showed 2.5/5. Three suspected issues identified (gap %, price filter, catalyst flag) but tabled pending data verification. Documented in `docs/session-notes/2026-01-27-five-pillars-validation-review.md`.

## Work Completed

### FIX 1: Wrap synchronous LLM calls in `asyncio.to_thread()`
**Files**: `backend/services/llm_validator.py`, `backend/api/routes.py`
**Risk**: LOW

- Added `import asyncio` to llm_validator.py
- Wrapped `_build_context()` in `asyncio.to_thread()` - offloads sync data assembly to thread pool
- Wrapped `is_available()` in `asyncio.to_thread()` - prevents 2s Ollama health check from blocking event loop
- Wrapped `_call_llm_with_json_extraction()` in `asyncio.to_thread()` - the main fix, prevents 60s LLM call from blocking
- Wrapped `is_available()` in routes.py `/validate/status` endpoint

**Verification**: During a 5.7s LLM validation call, candle requests completed in 200-400ms (not blocked).

### FIX 2: Route-level cache short-circuit before Schwab API calls
**Files**: `backend/api/routes.py`, `backend/services/llm_validator.py`
**Risk**: LOW

- Added `get_cached_result()` method to LLMValidator
- Cache check in route before fetching Schwab quote - avoids unnecessary API calls for cached validations
- Moved `config = load_config()` and `validator = get_validator(config)` above the Schwab quote fetch

**Verification**: POST /validate/XHLD returned in 209ms when cached (vs 5.7s for uncached).

### FIX 3: Decouple validation timer from watchlist polling in React
**File**: `src/renderer/App.tsx`
**Risk**: LOW

- Replaced `useCallback` import with `useRef`
- Separated ranking refresh (cheap, runs on data change) from LLM validation (expensive, fixed 60s timer)
- Used `useRef` to hold latest watchlist/runners data without triggering effect re-runs
- 2s initial delay lets first watchlist fetch complete before first validation
- Empty `[]` dependency ensures timer is created once and never torn down/recreated

### FIX 4: Watchlist shallow equality check
**File**: `src/renderer/store/watchlistStore.ts`
**Risk**: LOW

- Changed `create<WatchlistState>((set) =>` to `create<WatchlistState>((set, get) =>`
- Added `watchlistChanged()` comparison function (checks length + symbol + price)
- Prevents unnecessary store updates when watchlist data hasn't changed between polls

### Zombie Process Cleanup
**File**: `launcher.py`
**Risk**: LOW

Three layers of defense:
1. **`cleanup_stale_processes()`** on startup - kills stale processes on ports 8081/5173
2. **`atexit.register(self.cleanup)`** - ensures cleanup on abnormal exit
3. **`_kill_port_holders()`** - final safety after PID-based cleanup
4. Changed `taskkill /F /T /PID` to `taskkill /F /PID` (no tree kill - prevents killing trader app)
5. Added `_cleaned_up` guard against double-cleanup

### Semaphore Timeout (from prior session)
**File**: `backend/services/schwab_client.py`

- Added `asyncio.wait_for(_get_semaphore().acquire(), timeout=10.0)` with `TimeoutError` handling
- Prevents indefinite semaphore starvation when all slots busy

### Error Overlay (from prior session)
**File**: `src/renderer/components/charts/MultiChartGrid.tsx`

- Added `primaryError` to store subscription
- Displays error overlay when chart data fails to load

### Troubleshooting Documentation
**Files**: `docs/session-notes/2026-01-27-chart-not-displaying-troubleshooting.md`, `docs/session-notes/2026-01-27-five-pillars-validation-review.md`

- Chart display diagnosis flowchart with 5 documented failure modes
- Five Pillars validation review with XHLD case study and verification steps

## Testing Checklist
- [x] Backend responds to API requests during LLM validation (asyncio.to_thread working)
- [x] Cached validation returns in ~200ms (route-level cache working)
- [x] Watchlist API responds in ~200ms
- [x] Candle API responds in ~200ms
- [x] LLM validation status endpoint working (returns `available: true`)
- [x] Validation not spamming every 5s (verified in logs)
- [ ] Long-running stability test (30+ minutes)
- [ ] App exit cleanup verified (no zombie processes)
- [ ] All changes committed and pushed

## Files Modified

| File | Description |
|------|-------------|
| `backend/services/llm_validator.py` | asyncio.to_thread wrapping for 3 sync calls + get_cached_result() method |
| `backend/api/routes.py` | Route-level cache short-circuit + is_available() thread wrapping |
| `backend/services/schwab_client.py` | Semaphore timeout (10s) to prevent starvation |
| `launcher.py` | 3-layer zombie process defense + safe taskkill (no tree kill) |
| `src/renderer/App.tsx` | Separated ranking refresh from validation timer (useRef pattern) |
| `src/renderer/store/watchlistStore.ts` | Shallow equality check to prevent unnecessary re-renders |
| `src/renderer/components/charts/MultiChartGrid.tsx` | Error overlay display |
| `docs/session-notes/2026-01-27-chart-not-displaying-troubleshooting.md` | NEW - Troubleshooting guide |
| `docs/session-notes/2026-01-27-five-pillars-validation-review.md` | NEW - Five Pillars review |

## Key Takeaways
- **`asyncio.to_thread()` is the right fix** when you can't modify the underlying sync library (OllamaProvider lives in trader app codebase). Offloads blocking calls to thread pool without changing any logic.
- **React dependency cascades are subtle** - a `useCallback` that depends on a new array reference (from Zustand store) will re-fire every time the store updates, even if the data is identical. `useRef` breaks the chain.
- **`taskkill /T` (tree kill) is dangerous** on Windows - it walks the process tree upward and can kill unrelated processes. Always use `/PID` only unless you're certain about the process hierarchy.
- **Two-layer caching** is important for expensive operations: frontend timer prevents request storms, backend cache prevents redundant computation.
- **PowerShell `Invoke-RestMethod` startup overhead** (~4s) is misleading for benchmarking - `curl` shows the true API latency (~200ms).

## Performance Verification Results

| Endpoint | Response Time | Notes |
|----------|--------------|-------|
| GET /api/watchlist | ~200ms | Healthy |
| GET /api/candles/XHLD | ~200ms | Healthy |
| GET /api/validate/status | ~2.2s | Expected (2s Ollama health check timeout) |
| POST /validate/XHLD (cached) | ~200ms | Route-level cache working |
| POST /validate/NUWE (uncached) | ~5.7s | Real LLM call, event loop NOT blocked |
| GET /api/candles during LLM call | ~200-400ms | Proves asyncio.to_thread working |

## Next Steps
- Commit all changes (7 modified files + 2 new docs)
- Push to GitHub
- Run long-term stability test (30+ minutes)
- Verify clean app exit (no zombie processes)
- Five Pillars validation review (tabled - needs data verification before code changes)

---

**Last Updated**: 2026-01-27
